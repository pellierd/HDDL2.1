\def\year{2022}\relax
%File: formatting-instructions-latex-2021.tex
%release 2021.2
\documentclass[letterpaper]{article} % DO NOT CHANGE THIS
\usepackage{aaai22}  % DO NOT CHANGE THIS
\usepackage{times}  % DO NOT CHANGE THIS
\usepackage{helvet} % DO NOT CHANGE THIS
\usepackage{courier}  % DO NOT CHANGE THIS
\usepackage[hyphens]{url}  % DO NOT CHANGE THIS
\usepackage{graphicx} % DO NOT CHANGE THIS
\urlstyle{rm} % DO NOT CHANGE THIS
\def\UrlFont{\rm}  % DO NOT CHANGE THIS
\usepackage{natbib}  % DO NOT CHANGE THIS AND DO NOT ADD ANY OPTIONS TO IT
\usepackage{caption} % DO NOT CHANGE THIS AND DO NOT ADD ANY OPTIONS TO IT
\frenchspacing  % DO NOT CHANGE THIS
\setlength{\pdfpagewidth}{8.5in}  % DO NOT CHANGE THIS
\setlength{\pdfpageheight}{11in}  % DO NOT CHANGE THIS
\usepackage[ruled,linesnumbered,noend]{algorithm2e}
\usepackage{multirow}
\usepackage{subcaption}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{bbm}
\usepackage{subfiles}
\usepackage{listings}
\usepackage{xcolor}


\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\definecolor{myred}{rgb}{0.9,0.2,0.2}


\lstdefinelanguage{pddl}
{
  sensitive=false,    % not case-sensitive
  morecomment=[l]{;}, % line comment
  alsoletter={:,-},   % consider extra characters
  morekeywords={
    define,domain,problem,not,and,or,when,imply,forall,exists,either,
    :domain,:extends,:requirements,:types,:objects,:constants,
    :constraints,:ordered-substasks,:subtasks,:tasks,
    :predicates,:action,:durative-action,:duration,:method,:durative-method,
    :htn,:parameters,:precondition,:condition,:effect,:functions,
    :fluents,:primary-effect,:side-effect,:init,:goal,assign
    :strips,:adl,:equality,:task,:typing,:conditional-effects,:metric,
    :negative-preconditions,:disjunctive-preconditions,
    :existential-preconditions,:universal-preconditions,:ordered-subtasks,:ordering
  },
  keywords=[2]{object,at,start,over,all,end,always,at-most-once,sometime-before,sometime,sometime-after,hold-during,hold-between,hold-after,within,minimize,maximize,total-time} % Objects, temporal elmts
  keywords=[3]{calib_direction,image_direction,instrument,satellite,mode}, % Types
  keywords=[4]{calibrate,turn_approx,turn_precise,take_image,turn_to,activate_instrument,point_to,take_video,method_stereo,do_observation_stereo, do_observation,decrease_overall_quality,method_observe}, % Actions, Methods
  keywords=[5]{observable,calibrated,pointing,supports,power_on,power_avail,on_board,calib_target,have_image,
  image-quality,calib-time,turn-time} % Functions and predicetes
}

\lstset
{
  language={pddl},
  basicstyle=\small\ttfamily, % Global Code Style
  captionpos=b, % Position of the Caption (t for top, b for bottom)
  extendedchars=true, % Allows 256 instead of 128 ASCII characters
  tabsize=2, % number of spaces indented when discovering a tab
  columns=fixed,
  keepspaces=true,
  showstringspaces=false,
  breaklines=true,
  numberstyle=\tiny\ttfamily, % style of the line numbers
  commentstyle=\color{mygrey}, % style of comments
  keywordstyle=\bfseries, % style of keywords
  keywordstyle=[2]\color{mymauve},
  keywordstyle=[3]\color{mygreen},
  keywordstyle=[4]\color{blue},
  keywordstyle=[5]\color{myred},
  stringstyle=\color{blue}, % style of strings
}

\sloppy

% Don't use commands within pdfinfo
%\pdfinfo{
%/Title (An Accurate PDDL Domain Learning Algorithm from Partial and Noisy Observations)
%/Author (Maxence Grand, Damien Pellier, Humbert Fiorino)
%}

\pdfinfo{
/Title (HDDL2.1 Semantics and Syntax)
/Author (Paper \#)
}

\newtheorem{definition}{Definition}

\newcommand{\at}{\text{\it at}}
\newcommand{\holdafter}{\text{\it hold-after}}
\newcommand{\holdduring}{\text{\it hold-during}}
\newcommand{\before}{\text{\it before}}
\newcommand{\after}{\text{\it after}}
\renewcommand{\between}{\text{\it between}}
\newcommand{\atstart}{\text{\it at start}}
\newcommand{\atend}{\text{\it at end}}
\newcommand{\always}{\text{\it always}}
\newcommand{\overall}{\text{\it overall}}
\newcommand{\sometimes}{\text{\it sometimes}}
\newcommand{\sometimebefore}{\text{\it sometimes-before}}
\newcommand{\sometimeafter}{\text{\it sometimes-after}}
\newcommand{\alwayswithin}{\text{\it always-within}}
\newcommand{\within}{\text{\it within}}
\newcommand{\atmostonce}{\text{\it at-most-once}}

\newcommand{\name}{\text{\it name}}
\newcommand{\pre}{\text{\it precond}}
\newcommand{\param}{\text{\it param}}
\newcommand{\effect}{\text{\it effect}}
\newcommand{\add}{\text{\it effect}^{+}}
\newcommand{\del}{\text{\it effect}^{-}}
\newcommand{\duration}{\text{\it duration}}
\newcommand{\tstart}{\text{\it start}}
\newcommand{\tend}{\text{\it end}}
\newcommand{\tinv}{\text{\it inv}}
\newcommand{\task}{\text{\it task}}
\newcommand{\tn}{\text{\it tn}}
\newcommand{\hbefore}{\text{\it xx }}
\newcommand{\hafter}{\text{\it xx }}

\setcounter{secnumdepth}{2}

\setlength\titlebox{2.5in}
\title{HDDL 2.1: Towards Defining a HTN Formalism with Time}
\author{
Damien Pellier, Humbert Fiorino\\
Univ. Grenoble Alpes, LIG\\
38000 Grenoble, France\\
\{Damien.Pellier, Humbert.Fiorino\}@univ-grenoble-alpes.fr}

\title{HDDL 2.1: Towards Defining a HTN Formalism with Time}
\author{Paper \#}

\sloppy

\begin{document}
\maketitle

\begin{abstract}
Real world applications as in industry and robotics need modelling rich and diverse automated planning problems. Their resolution usually requires coordinated and concurrent action execution. In several cases, these problems are naturally decomposed in a hierarchical way and expressed by a Hierarchical Task Network (HTN) formalism. Recently, HDDL, a hierarchical extension of the Planning Domain Definition Language (PDDL) has been proposed. However, unlike PDDL 2.1, it does not allow to represent planning problems with numerical and temporal constraints, which are essential for real world applications.

We propose to fill the gap between HDDL and these operational needs and to extend HDDL by taking inspiration from  PDDL 2.1 in order to express numerical and temporal expressions. This paper opens discussions on the semantics and the syntax needed for this HDDL 2.1 extension.
\end{abstract}

\section{Introduction}

Real world applications of Automated Planning, like in industry and robotics, require modelling rich and diverse scenarios.
In several cases, such  planning problems are naturally decomposed in a hierarchical way, with compound tasks that refine in different ways their execution model.
These real world applications of planning use both numerical and temporal constraints to define the agents synchronisation on collaborative tasks, and sub-tasks decomposition. In fact, concurrency between actions, their duration, and agents coordination in HTN problems are needed to find solutions for nontrivial tasks in complex scenarios and require to make explicit the representation of time \citep{ghallabnautraverso2016}.

The Hierarchical Task Network (HTN) formalism \citep{erol94} is used to express a wide variety of planning problems in many real-world applications, e.g., in task allocation for robot fleets \citep{Milot21}, video games \citep{Menif14} or industrial contexts such as software deployment \citep{Georgievski17}. Over the last years, much progress has been made in the field of hierarchical planning \citep{bercher19}. Novel systems based on the traditional, search-based techniques have been introduced~\citep{Bit-Monnot:16,ramoul17,Shivashankar17,Bercher17,Holler19,holler20,Holler21}, but also new techniques like the translation to STRIPS/ADL~\citep{Alford09,Alford16,behnke2022}, or revisited approaches like the translation to propositional logic~\citep{Behnke2018totSAT,Behnke2019orderchaos,Schreiber2019SAT,Schreiber21,behnke2021}.

Despite these advances, not all these systems use the same formalism to represent hierarchical task decomposition. This makes difficult to compare the different approaches and to promote HTN planning techniques, even if some formalism are more adopted than others. For these reasons, an extension of the PDDL (Planning Domain Description Language)~\citep{mcdermott98},  used in the International Planning Competitions (IPC), has been proposed. This extension \citep{holler20}, called HDDL (Hierarchical Planning Domain Description Language), is based on PDDL 2.1 \citep{fox03} and is the result of several discussions within the planning community \citep{Holler19b} to fill the need of a standard language for the first Hierarchical Planning track of IPC 2020. In this first version, it was decided that, considering the efforts to develop the language and related tools, none of the temporal and numerical features of PDDL would be included. In this paper, we propose the semantics and the syntax for a temporal extension of HDDL, to match the needs of the planning community and the applications of planning. This work was accomplished collectively after the ICAPS workshop HPlan in 2022.

Our motivation is grounded on the compelling need to devise applications involving autonomous systems, i.e. agents, which must coordinate to fulfil hierarchical tasks containing both numerical and temporal constraints.
%As a matter of fact, action concurrency and agent coordination are needed in HTN problems to find solutions for nontrivial tasks in complex scenarios, like collaborative robotic missions \citep{weser2010htn}.
% TODO Revoir la fin, si ça change en cours de route
Starting from a real satellite application example, we propose to extend HDDL including elements of PDDL 2.1 and ANML to express temporal and numerical expressions.
This is intended to initiate discussions within HTN community on establishing a standard -- HDDL 2.1~-- aimed at filling the gaps between existing hierarchical-temporal planning approaches. To that end, we make this preliminary extension of HDDL an open source project with a publicly available repository.

The rest of the paper is organised as follows. In Section 2 we define the basic concepts of the proposed extension. In Sections 3 and 4 we set down the semantics for Temporal HTN planning. Section 5 describes our extension of the HDDL 1.0 syntax to deal with time, numeric and constraints in method declaration. We conclude discussing the main features of the proposed language. % The full syntax of our HDDL dialect is presented in the appendix.


%dealing with temporal and numeric expressions, for which we will made public a parser,
%The link to the git repository created to animate the discussions on the extension of the language will also be added in the final version of the paper. % https://github.com/pellierd/BNF-HDDL2.1

% The contribution of this paper is twofold: (1) an extension of HDDL inspired from PDDL 2.1 and ANML to express temporal and numerical expressions, and (2) a parser implementation of the language. The parser is built upon the PDDL4J library \citep{Pellier18} available online\footnote{\url{https://github.com/pellierd/pddl4j}} and will be made public in the camera ready version of this paper.
%  DOUBLE BLIND REVIEW
% part of the PDDL4J library \citep{Pellier18} available online\footnote{\url{https://github.com/pellierd/pddl4j/tree/hddl2.1}}.

Our reflection on HTN planning with time are based on a commercial optical Earth Observing Satellite (EOS) study case, which delimits our requirements for this new language, namely \emph{durative actions} and \emph{durative methods}, \emph{method preconditions}, \emph{numeric preconditions}, and \emph{timed ordering constraints}. The examples provided to illustrate HDDL~2.1 are shaped on the International Planning Competition hierarchical satellite domain~\citep{schattenberg2020}, extended to utilize the temporal features, as well as the orderings and the hierarchical constraints of the proposed language extension.

\section{Lifted Temporal HTN planning}

% Dire que pour des raisons de places les fonctions n'ont pas été inclues

Throughout this section, we will use common notations from first-order logic, which we assume to be known (see \cite{xx} for formal definitions). In the lifted formalism of HDDL 2.1, we assume for the sake of simplicity that all logical formulae are over a {\it function-free} first-order logic language ${\cal{L}} = (V, C, P)$. ${\cal{L}}$ consists of sufficiently many {\it constant} $c \in C$ representing the {\it objects} in the real world, {\it variables} $x \in V$ and {\it predicates} $p \in P$. Predicates have parameters that are either variables or constants. The predicate arity is the number of predicate parameters. For instance, $p(x, c)$ is a 2-arity predicate.

We can now define {\it formulas} in a function-free first-order logic \cite{ghallab}: (i) a predicate is a formula ; (ii) if ${\phi}$ and ${\psi}$ are formulas, then $\neg \phi$, $\phi \vee \psi$ and $\phi \wedge \psi$ are formulas ; (iii) if $\phi$ is a formula and $x$ is a variable, then $\forall x \phi$ is a formula. We define $\exists x \phi$ as $\neg \forall x \neg \phi$, and $\phi \rightarrow \psi$ as $\neg \phi \vee \psi$. $\forall$ and $\exists$ are respectively the universal and the existential quantifier.

Conceptually, grounding a formula consists in generating a set of variable-free i.e. {\it ground} formulas \cite{helmert} as follows: a variable $x$ in a quantifier-free formula $\phi$ is eliminated by replacing $\phi$ with $|C|$ copies, one for each $c \in C$, where $x$ is substituted with $c$ in the respective copy. This substitution is denoted by $\phi[x/c]$. Regarding quantified formulas, $\forall x \phi$ is replaced by $\bigwedge_{c \in C} \phi[x/c]$ and $\exists x \phi$ by $\bigvee_{c \in C} \phi[x/c]$. We refer the reader to \cite{behnke20,ramoul17} for further details on grounding implementation. Suffice to say it is always possible to transform a formula in function-free first-order logic into a finite set of ground formulas in propositional logic.

A {\it state} $s$ is a set of ground predicates. For the sake of conciseness, we will also consider $s$ as a Herbrand interpretation that assigns $true$ to all ground predicates in $s$, and $false$ to all ground predicates not in $s$. From this, a truth value can be computed for every {\it ground} formula from ${\cal{L}}$ by using the usual rules for logical composition. For instance, $\phi \wedge \psi$ is true in $s$ if and only if both $\phi$ and $\psi$ are true in $s$. Without loss of generality, a formula (not necessarily ground) $\phi$ is true in $s$ if and only if grounding $\phi$ generates at least one ground formula true in $s$. We will use the notation $s \models \phi$ to mean that the formula $\phi$ is true in $s$.
%A first-order formula is defined over $\cal{L}$ is either (i) an atomic formula $\phi \in P$, (ii) a negated formula $\neg\phi$, (iii) a conjunction of formulas $\phi_1 \wedge \phi_2$, (iv) a disjunction of formulas $\phi_1 \vee \phi_2$, (v) an implication of formulas $\phi_1 \rightarrow \phi_2$ or (vi) a quantified formula $\forall x \phi$ or $\exists x \phi$ where $x$ is a freexxx typed variable in $V$.

%set of ground atomic formulas defined over the $\cal{L}'$ predicates where all parameters are bound, i.e., replaced by a constants from $C$. A state $s$ is a model that assign {\it true} to all ground atomic formulas in $s$, and {\it false} to all ground atomic formulas not in $s$. Thus, a negated formula $\neg\phi$ is {\it true} in a state $s$, noted $s \models \neg \phi$, if only $\phi$ is not in $s$;  $s \models \phi_1 \wedge \phi_2$ if only both $\phi_1$ and $\phi_2$ is {\it true} in $s$; $s \models \phi_1 \vee \phi_2$ if $\phi_1$ or $\phi_2$ is {\it true} in $s$ and $s \models \phi_1 \rightarrow \phi_2$ if  $s \models \phi_1 \vee \neg \phi_2$; $\forall x \phi$ if for all possible values of $x$ in $C$ $s \models \phi$ and $\exists x \phi$ if it exists at least one value of $x$ in $C$ s.t $s \models \phi$.

 A key concept in HTN planning and a fortiori in temporal HTN planning is the concept of {\it task}. Each task is given by a name and a list of parameters. We distinguish two kinds of tasks: the actions, also called primitive tasks, and the abstract tasks (or coumpound tasks).

 %A {\it task} is defined as an atomic formula given by its name followed by a parameter sequence that could be either a typed variable in $V$ or typed constant in $C$. There are two kinds of tasks: primitive tasks that could be carried out by a durative action in the sense of classical temporal planning \cite{fox03} and abstract tasks that could be refined by applying methods that define how to decompose the task into subtasks. The purpose of abstract task is not to induce state transition unlike action, but to reference a predefined mapping to one or more tasks which that abstract task can be refined. This mapping is given by a set of decomposition methods.

 Let us start by defining the concepts of {\it snap} and {\it durative actions}, which are the primnitive taks, based on the concepts of \cite{abdulaziz22}.

A snap action is an action, which execution is instantaneous, in the sense of classical planning. % duration \epsilon << d
\begin{definition}[Snap Action] A {\em snap action} $a$ is a tuple $\bigl(\name(a), \pre(a), \effect(a) \bigr)$: $\name(a)$ is the name of $a$, the precondition $\pre(a)$ is a first-order formula $s \models \phi$ in state $s$ to execute $a$, and the effects \effect(a) produced by the execution of $a$. $\effect(a) = \add(a) \cup \del(a)$ ($\add(a) \cap \del(a) = \emptyset$), $\add(a)$ and $\del(a)$ are conjunctions of predicates, respectively true and false after the execution of $a$.
\end{definition}

\begin{definition}[Durative Action]
A {\em durative action} $a$ is a tuple $\bigl(\name(a), \tstart(a), \tend(a), \tinv(a), d\bigr)$: $\name(a)$ is the name of $a$, $\tstart(a)$ and $\tend(a)$ are snap actions; $\tinv(a)$ is a first-order formula that must hold in all the states after the execution of $start(a)$ and until $end(a)$, and $d$ is the duration of $a$. $start(a)$ and $end(a)$ are time events.
\end{definition}
Hence, actions do change the state of the world. How states change will be formally defined in Section \ref{THTN}.

Unlike a primitive task, % (i.e. a snap or durative action),
a {\it compound task} does not change the world state.
A compound task is identified by a name and defines the way other --possibly ordered-- tasks (either primitive or compound) must be achieved with respect to some constraints in order to refine it.
For instance, in the task of serving a dinner, {\it deliver-dinner(?food-style, ?place)} is the compound task consisting in performing first the task of serving the starters, then the main course, etc. In that sense,  {\it deliver-dinner(?food-style, ?place)} can be refined in: {\it serve-starters(?food-style, ?place)},  {\it serve-main-course(?food-style, ?place)}, etc. This mapping between tasks is achieved by the Temporal Task Networks and the methods as defined above. Like primitive tasks, compound tasks have also a start event and a end event, which will be associated to a time point in Section \ref{THTN}.

%% Satellite example



We will continue our description of HTN planning with time using a commercial optical Earth Observing Satellite (EOS) study case.
%, which delimits our requirements for this new language, namely \emph{durative actions} and \emph{durative methods}, \emph{method preconditions}, \emph{numeric preconditions}, and \emph{timed ordering constraints}.
%We present thereafter this real use case of an EOS with the mission of observing areas on the surface of the planet and embedding the capacity of producing and executing autonomous plans.
This example is shaped on the International Planning Competition hierarchical satellite domain~\citep{schattenberg2020}, and is intended to illustrate the temporal features, as well as the orderings and the hierarchical constraints of the proposed language extension.

New generations of commercial EOSs guarantee better performances by embedding a certain degree of autonomy on-board~\citep{pralet2019}. An automated planner is expected to produce new observation mission plans whenever environment changes or new requests are sent from ground control. Because observation tasks depend on the environment ---which is not known in advance--- this is a planning problem and not just a scheduling matter~\citep{rodriguez-moreno2004}. 
%
The EOS mission goal is then to fulfil a set of \emph{Acquisition Requests} of images of the Earth surface.
%Requests can be single images, which can be obtained by powering on sensors, and pointing at the sites of interest.
The different modalities of fulfilling those requests require the extension of the satellite domain to a temporal model.

Considering the structure of the requests that must be completed,
the action specifications have a \emph{duration} to reflect the warming up of certain instruments and the time to modify the attitude of the satellite. Figure \ref{pddl_calibrate} shows the calibrate action having a duration specific to the used instrument and defined in the problem initial state.
%
% explication basique
The action has conditions that, if set \texttt{at start} are equivalent to the Classical planning PDDL preconditions. In a similar way, effects set to happen \texttt{at end} are applied at the end of the action duration, similarly to classical planning effects.


\begin{figure}[!h]
	\begin{lstlisting}[language=pddl,mathescape]
(:durative-action calibrate
	:parameters (?s - satellite ?i - instrument ?d - calib_direction)
	:duration (= ?duration (calib-time ?i))
	:condition 	(and
			(at start (on_board ?i ?s))
			(at start (calib_target ?i ?d))
			(at start (pointing ?s ?d))
			(at start (power_on ?i)))
	:effect
		(and  (at end (calibrated ?i))) )
	\end{lstlisting}
	\caption{The calibrate action has a duration depending on the instrument calibration time\label{pddl_calibrate}}
\end{figure}


%%%%

%To formally define a method and define how break down a task into subtasks, it is necessary to define first the concept of {\it temporal task networks}.
\begin{definition}[Temporal Task Network]
A temporal task network $w = ({\cal{I}}, \alpha, {\cal{C}}_o, {\cal{C}}_v, {\cal{C}}_d, {\cal{C}}_t)$ is a partially temporal ordered multi-set of tasks $\cal{T}$, where
\begin{itemize}

    \item $\cal{I}$ is a set (possibly empty) set of tasks identifiers. Task identifiers are arbitrary symbols, which serve as place holders for the actual tasks they represent. Identifiers are needed because tasks can occur multiple times within the same task network.

    \item $\alpha: {\cal{I}} \rightarrow {\cal{T}}$ maps task identifiers to tasks,

    \item ${\cal{C}}_o$ is a set of temporal qualitative ordering constraints over the start or the end events of the tasks in $\cal{I}$. The possible qualitative temporal ordering are those from the classical point algebra \cite{broxvall03}: $<$, $\leq$, $>$, $\geq$, $=$ and $\neq$. For instance, the temporal ordering constraint $\tstart(t_1) < \tend(t_2)$ expresses that the start of the task $t_1$ must occur strictly  before the end of the task $t_2$.

    \item ${\cal{C}}_v$ is a set of parameter constraints. Each constraint can bind two variables to be equal or non-equals, or similarly bind a variable to a constant. % TODO Peut être rajouter un exemple pour être symetrique

    \item ${\cal{C}}_d$ is a set of durative constraints over the duration of the tasks $\cal{I}$. For instance, let $t_1, t_2 \in {\cal{I}}$ and $w$ a task network; the durative constraints $\duration(t_1) < \duration(t_2)$ expresses that the duration of $t_1$ must be strictly lower that $t_2$, and the constraint $\duration(w) \geq \duration(t_1) * \duration(t_2)$ expresses that the duration of $w$ is greater or equal to the product of the durations of $t_1$ and $t_2$. Durative constraints can be expressed in terms of start and end event of a task. For instance the previous constraint $\duration(t_1) < \duration(t_2)$ can be expressed as  $\tend(t_1) - \tstart(t_1) < \tend(t_2) - \tstart(t_2)$.

    \item ${\cal{C}}_t$ is a set of decomposition trajectory constraints of the form $(\at \ e \ \phi)$. This constraint expresses that some properties defined by the logical formula $\phi$ must hold in the state at the time event $e$. We will show in Section~\ref{Sec:Decomposition-Constraints-Semantics}, how to extend this simple constraint to more expressive ones proposed in HDDL~2.1.
   \end{itemize}
\end{definition}

Note that a temporal task network is ground if all its variables are bound to constants, and primitive if all its tasks ${\cal{I}}$ are primitive.

Methods allow to refer tasks to temporal task networks.
\begin{definition}[Method]
A {\em method} $m$ is a tuple $\bigl(\name(m), \task(m), \tn(m)\bigr)$, where $\name(m)$ is the name of the method, $\task(m)$ is the task refined by the method, and $\tn(m)$ is the temporal task network decomposing $\task(m)$ into the subtasks $\{\tn(m) \in \cal{I}\}$.
\end{definition}
 We can now define the planning domain and problem for Temporal HTN Planning.
\begin{definition}
 A {\em planning domain} $\cal{D}$ is a tuple $({\cal{L}}, {\cal{T}}, {\cal{A}}, {\cal{M}})$, where $\cal{L}$ is the first-order logic, $\cal{T}$ is the set of tasks, ${\cal{A}}$ is a set of actions and $\cal{M}$ is the set of methods. %We note ${\cal{T}}_p$ the set of primitive tasks and ${\cal{T}}_a$ the set of abstract tasks, s.t.  ${\cal{T}} = {\cal{T}}_p \cup {\cal{T}}_a$.
 \end{definition}

 The domain implicitly defines the set of all states $S$, being defined over all subsets of all ground predicates in $\cal{L}$.

 \begin{definition}
 A {\em planning problem} $\cal{P}$ is a tuple $({\cal{D}}, {s_0}, w_0, g)$, where $\cal{D}$ is a planning domain, $s_0 \in S$ is the initial state, $w_0$ is the initial temporal task network (not necessary ground), and $g$ is a formula (not necessary ground) describing the goal.
 \end{definition}

 \section{Temporal HTN planning Semantics}
 \label{THTN}

 The solution of a temporal HTN planning problem is an {\it executable} temporal task networks that is obtained from the problem initial task network by applying method decompositions and constraint satisfaction. Lifted problems are just a compact representation of their ground instances. With ground instances, there is not need to use variable constraints since they are satisfied by the grounding. Therefore, in this section, for the sake of simplicity, we define the semantics of a lifted problem in terms of its ground instances. For details on the grounding process, the reader is referred to \cite{behnke20,ramoul17}.

 % Definition d'un sequence temporel de tâches
Let us start by defining what is a temporal sequence of tasks.
\begin{definition}[Temporal Sequence of Tasks]
A {\it temporal sequence of tasks} $\pi$ is a sequence of tuples $\langle (t_0, e_0, d_0), \ldots,$ $(t_n, e_n, d_n) \rangle$ where $t_0, \ldots, t_n$ are the set of ground tasks defined over $\cal{T}$, $e_i \in \mathbb{Q}_{\geq 0}$ and $d_i \in \mathbb{Q}_{\geq 0}$ are rational numbers to which refer as the staring time event and the duration of the task $t_i$, respectively. For a temporal sequence of tasks $\pi$, we call a sorted sequence $e_0, \ldots, e_n$ of the set of rational numbers $\{e \ | \ (t, e, d) \in \pi\} \cup \{e + d \ | \ \langle t, e, d \rangle \in \pi\}$ the happening time events of the sequence $\pi$. % denoted $htps(\pi)$.
A temporal sequence of tasks is primitive if and only if every task $t_i \in \pi$ is primitive, i.e., can be carried out by a durative action.
\end{definition}

% Definition de l'executabilité d'une sequences de tâches dans un état
It is now necessary to define under which conditions such a sequence is {\it executable}. A central notion for that is the notion of snap action {\it non-interference}.
\begin{definition}[Non-Interference]
Two snap actions $a$ and $b$ are not interfering if and only if (i) $\pre(a) \cap \bigl(\add(b) \cup \del(b)\bigr) = \emptyset$, (ii) $\pre(b) \cap \bigl(\add(a) \cup \del(a)\bigr) = \emptyset$, (iii) $\add(a) \cap \del(b) = \emptyset$ and  $\add(b) \cap \del(a) = \emptyset$.
\end{definition}
Two snap actions or more can be executed at the same time, if they are not interfering. Execution semantics of snap actions are similar to the semantics of $\forall$-step parallel plans \cite{rintanen06}, and used in PDDL~2.1 \cite{fox03}. With this notion, it is now possible to formally define what an executable temporal sequence of tasks is.

\begin{definition}[Executable Temporal Sequence of Tasks]
A temporal sequence of tasks $\pi = \langle (t_0, e_0, d_0), \ldots,$ $(t_n, e_n, d_n) \rangle$ is executable in a state $s_0$ if and only if for every happening event $e_i$ of $\pi$ with $0 \leq i \leq n$:
(i) all $t_i$ refer to ground actions $a_i$,
(ii) $s_{i+1} = (s_i - \cup_{a \in B_{e_i}} \del(a)) \cup_{a \in B_{e_i}} \add(a)$
 where:
\begin{itemize}
 \item $B_{e_i} = \{ \tstart(a_i) \ | \ \langle a_i, e_i, d_i \rangle \in \pi\} \ \cup  \{\tend(a_i) \ | \ \langle a_i, e_i - d_i, d_i \rangle \in \pi\}$
 \item $I_{e_i} = \{ \tinv(a_i) \ | \ \langle a_i,e',d_i\rangle \in \pi \wedge e' < e_i < e' + d_i\}$.
 \end{itemize}
(iii) $B_{e_i}$ is {\em pairwise non-interfering},
(iv) $s_i \models \tinv(a_i)$ for every $\tinv(a_i) \in I_{e_i}$, (v) $s_i \models \pre(a_i)$ for every $a_i \in B_{e_i}$.
 \end{definition}

 This definition can easily be extended to a temporal task network.

  \begin{definition}[Executable Temporal Task Network] A temporal task network $w = ({\cal{I}}, \alpha, {\cal{C}}_o, {\cal{C}}_d, {\cal{C}}_t)$ is executable in a state $s_0$ if and only if there is an executable temporal sequence of tasks $\pi = \langle (\alpha(i_0), e_0, d_0), \ldots,$ $(\alpha(i_n), e_n, d_n)\rangle$ in $s_0$ where $i_0, \ldots, i_n$ are task identifiers in $\cal{I}$ that matches the following conditions: (i) $\pi$ matches the temporal constraints ${\cal{C}}_o$, (ii) $\pi$ matches the duration constraints ${\cal{C}}_d$, and (iii) the sequence of states $\langle (s_0, e_0, d_0), \ldots,$ $(s_n, e_n, d_n) \rangle$ resulting from the execution of $\pi$ matches the constraints ${\cal{C}}_t$.
  \end{definition}

It remains to define how to transform one temporal task network into another one by using method decomposition in order to obtain an executable task network.

\begin{definition}[Decomposition]
Let be a method \mbox{$m = \bigl(\name(m),$ $\task(m), tn(m)\bigr)$} with a task network $tn(m) = ({\cal{I}}^m, \alpha^m, {\cal{C}}_{o}^{m},{\cal{C}}_{d}^{m}, {\cal{C}}_{t}^{m})$ and a task network to decompose $w_1= ({\cal{I}}^1, \alpha^1, {\cal{C}}_{o}^{1},{\cal{C}}_{d}^{1}, {\cal{C}}_{t}^{1})$. We suppose ${\cal{I}}^m \cap {\cal{I}}^1 = \emptyset$. The latter case can be achieved by renaming. Then, $m$ decomposes a task identifier $i \in {\cal{I}}^1$ into a task network $w_2= ({\cal{I}}^2, \alpha^2, {\cal{C}}_{o}^{2},{\cal{C}}_{d}^{2}, {\cal{C}}_{t}^{2})$ if and only if $\alpha^1(i) = task(m)$ and
\begin{equation*} \label{eq1}
\begin{aligned}
{\cal{I}}^2 = & ({\cal{I}}^1 - \{i\}) \cup {\cal{I}}^m\\
\alpha^2 = & (\alpha^1 \cup \alpha^m)\\
{\cal{C}}^{2}_{o} = & {\cal{C}}^{1}_{o} \cup {\cal{C}}^{m}_{o} \\
        & \cup \{ c \ | \ \forall j \in {\cal{I}}^m \ \tstart(i) \leq \tstart(j) \}  \\
        & \cup \{ c \ | \ \forall j \in {\cal{I}}^m \ \tend(i) \geq \tend(j) \}  \\
{\cal{C}}^{2}_{d}  = & {\cal{C}}^{1}_{d} \cup {\cal{C}}^{m}_{d} \\
{\cal{C}}^{2}_{t}  = & {\cal{C}}^{1}_{t} \cup {\cal{C}}^{m}_{t} \\
\end{aligned}
\end{equation*}
\end{definition}

Now we can formally define a temporal task network solution.

\begin{definition}[Temporal Task Network Solution]
Let ${\cal{P}} = ({\cal{D}}, s_0, w_0, g)$ be a planning problem with $\cal{D} = ({\cal{L}}, {\cal{T}}, {\cal{A}}, {\cal{M}})$. A task network $w_s = ({\cal{I}}, \alpha, {\cal{C}}_o, {\cal{C}}_d, {\cal{C}}_t)$ is solution to a temporal HTN planning problem ${\cal{P}}$ if and only if:
\begin{itemize}
    \item There is a sequence of decompositions from $w_o$ to $w_s$ resulting from the application of the methods ${\cal{M}}$ of ${\cal{D}}$ and
%\item $w_s$ is executable and generates an executable temporal sequence of tasks from $s_0$ to a state $s \models g$.
\item $w_s$ is executable and the temporal sequence of states resulting from its execution starts with $s_0$ and leads to a state $s \models g$.
\end{itemize}
\end{definition}

\section{Decomposition Constraint Semantics}
\label{Sec:Decomposition-Constraints-Semantics}

Decomposition constraints assert conditions that must be met by the entire sequence of states visited during the execution of a solution task network. They are expressed through temporal modal operators over first-order formulas involving state predicates as in PDDL. The semantics of the decomposition constraints can be formally specified in a similar way to what has been done by \citep{gerevini05}. Let $w = ({\cal{I}}, \alpha, {\cal{C}}_o, {\cal{C}}_d, {\cal{C}}_t)$ be a ground task network, a state $s_0$ and a temporal sequence of tasks $\pi = \langle (t_0, e_0, d_0), \ldots, (t_n, e_n, d_n) \rangle $ with $t_0 = \alpha(i_0), \ldots, t_n = \alpha(i_n)$ where $\pi$ is the result of the decomposition of $w$ into primitive tasks by applying method decompositions of the planning problem. We denote by $\langle (s_0, e_0, d_0), \ldots, (s_n, e_n, d_n) \rangle$ the sorted temporal sequence of states produced by the execution of $\pi$ in $s_0$ according to its happening event $e_i$ with $i \leq 0 \leq n$. $w$ satisfies a constraint $(\at \ e \ \phi) \in {\cal{C}}_t$ iff $\exists s_i \in \langle (s_0, e_0, d_0), \ldots, (s_n, e_n, d_n) \rangle$ such that $s_i \models \phi$. Each decomposition constraint defined in HDDL~2.1 can be rewritten in terms of constraints of the form $(\at \ e_i\ \phi)$. The proposed HDDL extension distinguishes two types of decomposition constraints:
\begin{itemize}
    \item the {\em temporal decomposition constraints} that define the constraints that must hold at specific happening event whose semantics is based on the plan trajectory constraints from PDDL~3.0. We have made the choice to keep the same constraints as introduced in PDDL~3.0 to stay consistent with PDDL.
    \item the {\em classical decomposition constraints} ($\before$, $\after$, $\between$) used in HTN planning introduced first by \citep{erol94} to represent constraints between tasks. We will show how the latter can be expressed with the former at the end of this section.
\end{itemize}

We conclude this section by building the semantics of the durative method preconditions on the semantics of the introduced decomposition constraints.

\subsection{Temporal Constraints Semantics}
\label{ssec:temporal-constraints-semantics}

% Dire explicitement que les contraintes ne concerne que le task netwok par conséquent le s0 et l'état initial de la séquence d'états du taskntwork. Ce chois a été fait pour ne limiter les effects de bord.


The semantics of temporal decomposition constraints are given below.

Constraint \holdduring~ expresses that some properties must always remain true during a time interval. It allows to specify temporal ``envelops''.
%
\begin{multline*}
\langle (s_0, e_0, d_0), \ldots, (s_i, e_i, d_i), \ldots, (s_n, e_n, d_n) \rangle \models \\
(\holdduring \ e_1 \ e_2 \ \phi)\ \text{iff} \ \forall e_i : e_1 \leq e_i \leq e_2 \ \text{such as} \ (\at \ e_i \ \phi)
\end{multline*}
%
Constraint \within~ says that some properties must be verified sometime before the begin of the execution of a specific event.
%
\begin{multline*}
\langle (s_0, e_0, d_0), \ldots, (s_i, e_i, d_i), \ldots, (s_n, e_n, d_n) \rangle \models   \\
\left(\within \ e \ \phi\right) \text{iff} \; \exists e_i: e_0 \leq e_i \leq e \; \text{such as}\ (\at \ e_i \ \phi)
%\: \ \text{and} \; e_i \leq e \qquad\qquad\quad\quad\quad
\end{multline*}
%
%
The pending constraint \holdafter \ says \ that some properties must be verified sometime after the begin of the execution of a specific event.
%
\begin{multline*}
\langle (s_0, e_0, d_0), \ldots, (s_i, e_i, d_i), \ldots, (s_n, e_n, d_n) \rangle \models   \\
\left(\holdafter \ e \ \phi\right) \text{iff} \; \exists e_i: e \leq e_i \leq e_n \ \text{such as}\ (\at \ e_i \ \phi) %\: \ \text{and} \; e_i \geq e
% \qquad\qquad\quad\quad
\end{multline*}
%
 The constraints \atstart~ (respectively {\atend}) expresses that a specified logical formula $\phi$ must be true before  (respectively after) the start of the first task of a task network (respectively the end of the last task). Both constraints were added to simplify the expression of preconditions and effects of methods. %These two constraints can easily be rewritten in \before~ and \after~ constraints by adding a dummy task representing the first task and the last task of the task network.
%
\begin{multline*}
\langle (s_0, e_0, d_0), (s_1, e_1, d_1), \ldots, (s_n, e_n, d_n) \rangle \models\\
     (\atstart \ \phi)\ \text{iff}\ (\at \ e_0 \ \phi)
\end{multline*}
\begin{multline*}
\langle (s_0, e_0, d_0), (s_1, e_1, d_1), \ldots, (s_n, e_n, d_n) \rangle \models\\
    (\atend \ \phi)\ \text{iff}\ (\at \ e_n \ \phi)
\end{multline*}
%
As \cite{gerevini05}, we propose to add also modal operators : \always, \sometimes, \atmostonce. A constraint \always~ expresses that some properties $\phi$ must be satisfied whatever the decomposition of the task network.
%
\begin{multline*}
\langle (s_0, e_0, d_0), \ldots, (s_i, e_i, d_i), \ldots, (s_n, e_n, d_n) \rangle \models \\
 (\always \ \phi) \ \text{iff} \ \forall e_i : e_0 \leq e_i \leq e_n \: \text{such as} \ (\at \ e_i \ \phi)
\end{multline*}
%
A constraint \sometimes~ say that some properties must be verified sometimes in the decomposition of the task network.
%
\begin{multline*}
\langle (s_0, e_0, d_0), \ldots, (s_i, e_i, d_i), \ldots, (s_n, e_n, d_n) \rangle \models  \\
(\sometimes \: \phi) \ \text{iff} \ \exists e_i: e_0 \leq e_i \leq e_n \: \text{such as} \ (\at \ e_i \ \phi)
\end{multline*}
%

Constraint \atmostonce~ indicates that some properties must be satisfied at most once in the state sequence produced by the decomposition of the task network.
%
\begin{multline*}
\langle (s_0, e_0, d_0), \ldots, (s_n, e_n, d_n) \rangle \models (\atmostonce \ \phi) \\
 \text{iff} \ \forall e_i: e_0 \leq e_i \leq e_n \ \text{if} \ (\at~ e_i \ \phi) \ \text{then} \\
 \exists e_j: e_j \geq e_i \ \text{such as} \ \forall e_k: e_i \leq e_k \leq e_j \\
(\at \ e_k \ \phi) \text{ and} \ \forall e_k : e_k > e_j \: \text{such as} \ (\at \ e_k \ \neg\phi) \qquad\quad
\end{multline*}
%
Finally, we have the three last constraints introduced in PDDL~3.0: \sometimebefore, \sometimeafter~ and \alwayswithin. A constraint \sometimebefore~ (respectively \sometimeafter~) says that if some properties $\phi$ occurs at $e_i$ then $\psi$ must be verified sometime before (respectively after) $e_i$ in the sequence of states produced by the decomposition of the task network.
%
\begin{multline*}
\langle (s_0, e_0, d_0), \ldots, (s_i, e_i, d_i), \ldots, (s_n, e_n, d_n) \rangle \models   \\
(\sometimebefore \ \phi \ \psi) \ \text{iff} \; \forall e_i \ \text{if} \ (\at \ e_i \ \phi)\\
\exists e_j : 0 \leq e_j \leq e_i \: \text{such as} \ (\at \ e_j \ \psi) \qquad\qquad\quad\quad
\end{multline*}
%
\begin{multline*}
\langle (s_0, e_0, d_0), \ldots, (s_i, e_i, d_i), \ldots, (s_n, e_n, d_n) \rangle \models   \\
(\sometimeafter \ \phi \ \psi) \ \text{iff} \; \forall e_i \ \text{if} \ (\at \ e_i \ \phi)\\
\exists e_j : e_i \leq e_j \leq e_n \: \text{such as} \ (\at \ e_j \ \psi) \qquad\qquad\quad\quad
\end{multline*}
%
A constraint \alwayswithin~ says that if some properties $\phi$ occurs at $e_i$ then some properties $\psi$ must be verified after $e_i$ at the latest after a certain time $d$ in the sequence of states produced by the decomposition of the task network.
%
\begin{multline*}
\langle (s_0, e_0, d_0), \ldots, (s_i, e_i, d_i), \ldots, (s_n, e_n, d_n) \rangle \models   \\
(\alwayswithin \ \phi \ \psi \ d) \ \text{iff} \; \forall e_i \ \text{if} \ (\at \ e_i \ \phi)\\
\exists e_j : e_i \leq e_j \leq e_n \: \text{such as} \ (\at \ e_j \ \psi) \ \text{and} \ e_j - e_i \leq d \qquad
\end{multline*}

%%% SAT example


Figure \ref{pddl_durative_m_con} depicting the \textit{observe} method illustrates some temporal constraints semantics introduced here.
% section \ref{ssec:temporal-constraints-semantics}.
In this case, \texttt{pointing} at an observation site can be achieved by different subtasks. By requiring that this precondition of \mbox{\small\lstinline[language={pddl},basicstyle=\ttfamily]|durative-action take_image|} is performed  at most once, avoids useless satellite movements. 
Note that, besides the explicit subtask ordering, an implicit ordering between tasks 0 and 1 could have been forced by adding the constraint  \mbox{\small\lstinline[language={pddl},basicstyle=\ttfamily]|(within task1 (power_on ?i))|}, requiring that the instrument must be powered on \emph{before} turning towards the observation site.
%
\begin{figure}[h!]
	\begin{lstlisting}[language=pddl, basicstyle=\fontsize{8.5}{10}\selectfont\ttfamily, escapechar=~]
	(:durative-method method_observe
		:parameters (?d_prev - image_direction
      		   ?d - image_direction
		   ?s - satellite
		   ?i - instrument   ?m - mode)
		:task (do_observation ?d ?m)
		:duration
		   (< (duration task1) (calib-time ?i))~\label{l:mdur}~
		:subtasks (and
		   (task0 (activate_instrument ?s ?i))
		   (task1 (turn_to ?s ?d ?d_prev))
		   (task2 (take_image ?s ?d ?i ?m)))
		:ordering (and
		   (< task0 task2)
		   (< task1 task2))
		:constraints (and
		   (not (= ?d ?d_prev))
		   (at-most-once (pointing ?s ?d))) )~\label{l:mhb}~
	\end{lstlisting}
	\caption{\texttt{method\_observe} uses a duration inequality and a constraint over literals to constrain an ordering. Similarly, a decomposition can be constrained at method-level.\label{pddl_durative_m_con}}
\end{figure}
%%%%%%

\subsection{Classical Decomposition Constraints}

The {\em classical decomposition constraints} used in HTN planning introduced first by \citep{erol94} are $\before$, $\after$ and $\between$. The \before~ constraints are a generalisation of the classical notion of precondition. It has the form $\before(t, \phi)$ where $t$ is a task and $\phi$ a first-order formula that represents the properties that must be satisfied before $t$. The \after~ constraints are a generalisation of the classical notion of effects for a task network. It has the form $\after(t, \phi)$ where $t$ is a task $t$ and $\phi$ a first-order formula that represents the properties that must be satisfied after $t$. Finally, the \between~ constraints are a generalisation of the notion of causal link in plan space planning. It has the form $between(t_1\ t_2\ \phi)$ where $t_1$ and $t_2$ are tasks and $\phi$ is a first-order formula that represents the properties that must hold between the end of $t_1$ and the begin of $t_2$. We give below the formal semantics of these constraints based on the semantics of the previously introduced temporal constraints:
\begin{multline*}
\langle (s_0, e_0, d_0), \ldots, (s_n, e_n, d_n) \rangle \models  \\
(\before \ t \ \phi) \  \text{iff} \ (\at \ e_{\tstart(t)} \ \phi) \\
\langle (s_0, e_0, d_0), \ldots, (s_n, e_n, d_n) \rangle \models  \qquad \qquad \qquad \qquad \quad\\
(\after \ t \ \phi) \  \text{iff} \ (\at \ e_{\tend(t)} \ \phi) \\
\langle (s_0, e_0, d_0), \ldots, (s_i, e_i, d_i), \ldots, (s_n, e_n, d_n) \rangle \models \qquad \quad \\
    (\between \ t_1 \ t_2 \ \phi) \ \text{iff} \ \forall e_i :  \\
\tend(t_1) \leq e_i \leq \tstart(t_2) \ \text{such as} \ (\at \ e_i \ \phi) \qquad \quad
\end{multline*}

\subsection{Method Preconditions Semantics}

Durative methods may have preconditions and their preconditions are temporally annotated to give the time at which they are supposed to happen. As durative actions, methods can have three types of annotated preconditions: (1) $(\atstart \ \phi)$ meaning that $\phi$ must be true or happen at the start of the method; (2) $(\atend \ \phi)$ meaning that $\phi$ must be true or happen at the end of the method, and $(\overall \ \phi)$ meaning that $\phi$ must be true for the full duration of the method.


Formally, these three temporal preconditions can be rewritten in terms of decomposition constraints previously introduced. A precondition of type $(\atstart \ \phi)$ (respectively $(\atend \ \phi)$) is equivalent to adding a decomposition constraint $(\atstart \ \phi)$ (respectively $(\atend \ \phi)$), and a precondition of type $(\overall \ \phi)$ is equivalent to adding a decomposition constraint $(\always \ \phi)$. The preconditions of the methods can be seen as syntactic glue to express decomposition constraints of type $\atstart$, $\atend$ and $\always$.

\section{HDDL 2.1 Syntax}

The proposed syntax, called HDDL2.1, takes its roots in HDDL~\citep{holler20}.

\subsection{Domain Description}

\newcommand{\specReq}[1]{\ensuremath{\mathtt{^{#1}}}}

The domain definition has been extended to durative actions (line~\ref{l:durative-actions}) and durative methods (line~\ref{l:durative-methods}).
\begin{lstlisting}[escapechar=~]
<domain> ::= (define (domain <name>)
    [<require-def>]
    [<types-def>]~\specReq{:typing}~
    [<predicates-def>]
    [<functions-def>]~\specReq{:fluents}~
    [<constants-def>]
    [<task-defs>]
    <structure-def>*)
\end{lstlisting}

%
% Domain definition
%
% Requirement Statement
% Type Definition
% Domain Constant Definition
% Predicate Definition
%
% @HDDL 1.0

\noindent The definition of the basic domain elements is nearly unchanged.

\begin{lstlisting}[firstnumber=last, escapechar=~]
<require-def> ::= (:requirements <require-key>+)
<require-key> ::= ~\textit{(see \S\ref{Sec:Requirements})}~
<types-def> ::= (:types ~\mbox{<typed-list(<primitive-type>))}~
<predicates-def> ::= (:predicates <atomic-formula-skeleton>+)
<function-def> ::= (:<function-typed-list (atomic-function-skeleton)>)
<constants-def> ::= (:constants <typed-list (constant)>)
<atomic-formula-skeleton> ::= ~\linebreak~(<predicate> <typed-list(variable)>)
<atomic-function-skeleton> ::= ~\linebreak~(<function>~\linebreak~ <typed-list (variable)>)
<typed-list (x)> ::= x+ - <type> ~\linebreak~[<typed list (x)>]~\label{l:typedlist}~
<type> ::= (either <primitive-type>+)
<type> ::= <primitive-type>
<function-typed-list (x)> ::= x+ - ~\linebreak~<function-type> <function-typed-list(x)>
<function typed list (x)> ::=
<function-type> ::=~\specReq{:numeric-fluents}~number
<function-type> ::=~\specReq{:typing} \specReq{+} \specReq{:object-fluents}~<type>
<predicate> ::= <name>
<function> ::= <name>
<constant> ::= <name>
<variable> ::= ?<name>
<primitive-type> ::= <name>
<primitive-type> ::= ~object
\end{lstlisting}

%
% Task definition
%
% @HDDL 1.0
\noindent Abstract tasks are defined similarly to actions as in HDDL 1.0
\begin{lstlisting}[firstnumber=last, escapechar=~]
<tasks-def> ::= (:task <task-def>)
<task-def> ::= <task-symbol> ~\linebreak~:parameters (<typed list (variable)>)~\label{l:compTask}~
<task-symbol> ::= <name>
\end{lstlisting}

\noindent The structure of a temporal HDDL domain is composed of durative and non-durative methods and actions. Durative and non-durative actions are defined as in PDDL and non-durative methods as in HDDL.

\begin{lstlisting}[firstnumber=last, escapechar=~]
<structure-def> ::= <action-def>
<structure-def> ::=~\specReq{:durative-actions}~ ~\mbox{<durative-action-def>}~
<structure-def> ::= <method-def>
<structure-def> ::=~\specReq{:durative-methods}~ ~\mbox{<durative-method-def>}~
\end{lstlisting}

%
% Method Definition
%
% @HDDL 1.0
Methods consist of a parameter list (line~\ref{l:mparams}), the abstract task they decompose (line~\ref{l:mabstask}), and the resulting task network (line~\ref{l:msubtasks}). By setting the \verb+:method-preconditions+ requirement, one can use method preconditions (line~\ref{l:mprec}, which can be used for example to filter the hierarchical decomposition).

\begin{lstlisting}[firstnumber=last, escapechar=~]
<method-def> ::= (:method <name>~\label{l:methods}~
    :parameters (<typed list (variable)>)~\label{l:mparams}~
    :task (<task-symbol> <term>*)~\label{l:mabstask}~
    [:precondition <gd>]~\specReq{:method-preconditions}~~\label{l:mprec}~
    <tasknetwork-def>~\label{l:msubtasks}~)
\end{lstlisting}

%
% Durative Method Definition
%
% @HDDL 2.1
Like methods, durative methods have parameters, the abstract task they decompose, and the resulting task network, and, like durative actions, they can have duration constraints and a condition that has to hold to apply the decomposition. Note that, unlike for durative actions, duration constraints are not mandatory. By default the duration of a method is the sum of all the durations of the primitive tasks that compose it. However, it can be interesting to specify temporal constraints on the execution of the decomposition such as, for example, whatever decomposition is chosen, the duration of the primitive tasks must not exceed a given value, or that a subtask must last less than another subtask. These durative constraints can be declared if the requirement {\tt :durative-inequalities} is set. We use here the same requirement as for PDDL.

\begin{lstlisting}[firstnumber=last, escapechar=~]
<durative-method-def> ::=~\label{l:durative-methods}~
    :durative-method <name>
    :parameters (<typed list (variable)>)
    :task (<task-symbol> <term>*)
    [:duration <method-duration-constraint>]~\specReq{:duration-inequalities}~
    [:condition <da-gd>]~\specReq{:method-preconditions}~~\label{l:mcond}~
    <tasknetwork-def>~\label{l:msubtasks2}~)
\end{lstlisting}

%
% Task Definition
%
% @HDDL 1.0
The definition of task networks is used in method definitions as well as in the problem definition to define the initial task network. It contains the definition of sub-tasks (line~\ref{l:tnsubtasks}), ordering constraints (line~\ref{l:tnordering}), and logical constraints (line~\ref{l:tnconstraints}) on the sub-tasks of the method. We keep here the same definition as in HDDL.

When the key \verb+:ordered-subtasks+ is used, the network is considered totally ordered. In the other cases, ordering relations have to be defined explicitly. This is done by including ids into the task definition that can then be referenced in the ordering definition.

\begin{lstlisting}[firstnumber=last, escapechar=~]
<tasknetwork-def> ::=
    [~\textbf{:}~[~\textbf{ordered-}~][~\textbf{sub}~]~\textbf{tasks}~
        <subtask-defs>]~\label{l:tnsubtasks}~
    [~\textbf{:order}~[~\textbf{ing}~] <ordering-defs>]~\label{l:tnordering}~
    [:constraints <constraint-defs>]~\label{l:tnconstraints}~
\end{lstlisting}

%
% Subtasks
%
% @HDDL 1.0
\noindent The subtask definition can contain one or more subtasks.

\begin{lstlisting}[firstnumber=last, escapechar=~]
<subtask-defs> ::= () | <subtask-def> ~\linebreak~| (and <subtask-def>+)
<subtask-def> ::= (<task-symbol> <term>*) ~\linebreak~| (<subtask> (<task-symbol> <term>*))
<subtask> ::= <name>
\end{lstlisting}

%
% Ordering
%
% @HDDL 2.1
The ordering constraints are defined via the task ids, and have to induce a partial order. To deal with time we add time specifiers on task ids to specify if the ordering constraints are about the start time or the end time of the task. The time specifiers are like in PDDL: ~{\tt start} to define the start time of a task, and {\tt end}  to define the end time of a task. Note that we extend also the list of operators available to express ordering constraints between tasks. It has been extended to define any constraints on the start or end of a sub-task of a method, and allows to express all Allen's intervals \citep{allen81} between these subtasks.

\begin{lstlisting}[firstnumber=last, escapechar=~]
<ordering-defs> ::= () | <ordering-def> ~\linebreak~| (and <ordering-def>+)
<ordering-def> ::= ~\linebreak~(<d-task> <task-id> <task-id>)
<ordering-def> ::=~\specReq{:durative-action} \linebreak~(not (<ordering-def>))
<d-task> ::= <
<d-task> ::=~\specReq{:durative-action} ~>=
<d-task> ::=~\specReq{:durative-action} ~<=
<d-task> ::=~\specReq{:durative-action} ~>
<d-task> ::=~\specReq{:durative-action} ~=
<task-id> ::= <name>
<task-id> ::= ~\specReq{:durative-action} <time-task-id>~
<time-task-id> ::= (<time-specifier> ~\mbox{<task-id>)}~
<time-specifier> ::= ~start~
<time-specifier> ::= ~end
\end{lstlisting}

%
% Constraints extensions
%
% @HDDL 2.1
HDDL~1.0 only accepts equality constraints or inequality on method parameters in the task network. To increase the expressiveness of the language, we have chosen to add two kinds of constraints: the {\em classical decomposition constraints} ($\before$, $\after$, $\between$) used in HTN planning introduced first by \citep{erol94} to represent constraints between tasks for non temporal HTN problem and the {\em temporal decomposition constraints} based on the plan trajectory constraint from PDDL~3.0. The semantic of theses constraints were given in section~\ref{Sec:Decomposition-Constraints-Semantics}. To allow the specification of such the constraints added, it is necessary to use \verb+:method-constraints+.

\begin{lstlisting}[firstnumber=last, escapechar=~]
<constraint-def> ::= () | <constraint-def> | (and <constraint-def>+)
<constraint-def> ::= (not (= <term> <term>))~\linebreak~| (= <term> <term>)
<constraint-def> ::=~\specReq{:method-constraints}~  ~\linebreak~(~before <task-id> <gd>)~
<constraint-def> ::=~\specReq{:method-constraints}~  ~\linebreak~(~after <task-id> <gd>)~
<constraint-def> ::=~\specReq{:method-constraints}~  ~\linebreak~(~between <task-id> <task-id> <gd>)~
<constraint-def> ::=~\specReq{:durative-action + :method-constraints}~ ~\linebreak~<timed-constraint-def>
<timed-constraint-def> ::= ~\linebreak~(~at <timed-task-id> <gd>)~
<timed-constraint-def> ::= ~\linebreak~(~hold-during <timed-task-id> <gd>)~
<timed-constraint-def> ::= ~\linebreak~(~within <timed-task-id> <gd>)~
<timed-constraint-def> ::= ~\linebreak~(~hold-after <timed-task-id> <gd>)~
<timed-constraint-def> ::= ~\linebreak~(~at start <gd>)~
<timed-constraint-def> ::= ~\linebreak~(~at end <gd>)~
<timed-constraint-def> ::= ~\linebreak~(~always <gd>)~
<timed-constraint-def> ::= ~\linebreak~(~at-most-once <gd>)~
<timed-constraint-def> ::= ~\linebreak~(~sometime <gd>)~
<timed-constraint-def> ::= ~\linebreak~(~sometime-before <gd> <gd>)~
<timed-constraint-def> ::= ~\linebreak~(~sometime-after <gd>> <gd>)~
<timed-constraint-def> ::= ~\linebreak~(~always-within number <gd>> <gd>)~
\end{lstlisting}


%
% Action Definition
%
% HDDL 1.0
The orginal action or durative action definitions defined in PDDL stay mainly unchanged. The only difference is that for simplicity, it is not possible to specify preferences. The non-durative actions are defined as follows:

\begin{lstlisting}[firstnumber=last, escapechar=~]
<action-def> ::= (:action <task-def>~\label{l:action}~
    [:precondition <gd>]
    [:effect <effect>])
\end{lstlisting}

%
%  Durative Action Definition
%
% PDDL 3.0 add to HDDL 2.1
\noindent The durative actions are defined as follows:

\begin{lstlisting}[firstnumber=last, escapechar=~]
<durative-action-def> ::= ~\linebreak~(:durative-action <task-def>~\label{l:durative-actions}~
      :duration <duration-constraint>
      [:condition <da-gd)>]
      [:effect <da-effect>])
\end{lstlisting}


%
%  Durative Action Constraints Definition
%
% PDDL 3.0 add to HDDL 2.1
As in PDDL, duration constraints with the \verb|:duration-inequalities| requirement allow to express duration inequalities. The definition of the duration constraints for durative actions does not change.

\begin{lstlisting}[firstnumber=last, escapechar=~]
<action-duration-constraint> ::=~\specReq{:duration-inequalities}~(and ~\linebreak~ <simple-action-duration-constraint>+)
<action-duration-constraint> ::= ()
<action-duration-constraint> ::= ~\mbox{<simple-action-duration-constraint>}~
<action-simple-duration-constraint>::= ~\linebreak~(<d-op> ?duration <d-value>)
<action-simple-duration-constraint>::= ~\linebreak~ (~{at}~<time-specifier> ~\mbox{<simple-duration-constraint>}~)
<d-op> :: <=
<d-op> :: >=
<d-op> :: =
<d-value> ::= <number>
<d-value> ::=~\specReq{:numeric-fluents}~<f-exp>
<f-exp> ::=~\specReq{:numeric-fluents}~<number>
<f-exp> ::=~\specReq{:numeric-fluents}~(<binary-op> <f-exp> <f-exp>)
<f-exp> ::=~\specReq{:numeric-fluents}~(<multi-op> <f-exp> <f-exp>+)
<f-exp> ::=~\specReq{:numeric-fluents}~(- <f-exp>)
<f-exp> ::=~\specReq{:numeric-fluents}~<f-head>
<f-head> ::= (<function-symbol> <term>*)
<f-head> ::= <function-symbol>
<binary-op> ::= <multi-op>
<binary-op> ::= -
<binary-op> ::= /
<multi-op> ::= *
<multi-op> ::= +
<binary-comp> ::= >
<binary-comp> ::= <
<binary-comp> ::= =
<binary-comp> ::= >=
<binary-comp> ::= <=
\end{lstlisting}

%
%  Durative Method Constraints Definition
%
% @HDDL 2.1
The duration of a method is by default the sum of the durations of the sub-tasks that compose it. Optional constraints might be specified to restrict the allowed value for the
duration of the method or the sub-tasks that compose it. Therefore, it is necessary to be able to refer explicitly to the duration of a subtask and not only to the duration of the method with the variable {\tt ?duration}.

\begin{lstlisting}[firstnumber=last, escapechar=~]
<method-duration-constraint> ::=~\specReq{:duration-inequalities}~ (and~\linebreak~ <method-simple-duration-constraint>+)
<method-duration-constraint> ::= ()
<method-duration-constraint> ::= ~\mbox{<simple-method-duration-constraint>}~
<simple-method-duration-constraint>::= ~\linebreak~(<binary-comp> <duration> <td-value>)~
<simple-method-duration-constraint>::= ~\linebreak~(at <time-specifier> ~\mbox{<simple-method-duration-constraint>}~)
<duration> :: = ?duration
<duration> :: = <task-duration>
<td-value> ::= <d-value>
<td-value> ::= <task-duration>
<task-duration> :: = (duration <task-id>)
\end{lstlisting}

%
% Goal Description
%
% @HDDL 1.0
\noindent Compared to HDDL 1.0 we allow to define numerical and temporal preconditions. The syntax used from numeric preconditions is the same as that of PDDL 3.0. For the sake of simplicity, we chose to not include the preferences.
\begin{lstlisting}[firstnumber=last, escapechar=~]
<gd> ::= ()
<gd> ::= <literal (term)>
<gd> ::= (and <gd>*)
<gd> ::=~\specReq{:disjunctive-preconditions}~ (or <gd>*)
<gd> ::=~\specReq{:negative-preconditions}~ (not <gd>)
<gd> ::=~\specReq{:disjunctive-preconditions \ :negative-preconditions}~ ~\mbox{(imply <gd> <gd>)}~
<gd> ::=~\specReq{:existential-preconditions}~ ~\linebreak~(exists (<typed list (variable)>*) <gd>)
<gd> ::=~\specReq{:universal-preconditions}~ ~\linebreak~(forall (<typed list (variable)>*) <gd>)
<gd> ::= (= <term> <term>)
<gd> ::=~\specReq{:numeric-fluents} <f-comp>
<f-comp> ::= (<binary-comp> <f-exp> <f-exp>)
\end{lstlisting}

\begin{lstlisting}[firstnumber=last, escapechar=~]
<literal (t)> ::= <atomic formula(t)>
<literal (t)> ::= (not <atomic formula(t)>)
<atomic formula(t)> ::= (<predicate> t*)
\end{lstlisting}

\begin{lstlisting}[firstnumber=last, escapechar=~]
<term> ::= <name>
<term> ::= <variable>
\end{lstlisting}

%
% Goal Description
%
% PDDL 3.0 add to HDDL 2.1

\noindent The same approach is used for temporal precondition definition. The syntax used is the same as in PDDL 3.0.

\begin{lstlisting}[firstnumber=last, escapechar=~]
<da-gd> ::= <timed-gd>
<da-gd> ::= (and <da-gd>*)
<da-gd> ::=~\specReq{:universal-preconditions}~ (forall ~\linebreak~ <typed-list (variable)>) <da-gd>)
<timed-gd> ::= (~at <time-specifier> <gd>)~
<timed-gd> ::= (~over <interval> <gd>)~
<interval> ::= ~all
\end{lstlisting}

%
% Effects
%
% @HDDL 1.0
\noindent Symmetrically, we add to the effect definition the temporal and numeric aspect based on the same syntax as in PDDL 3.0.

\begin{lstlisting}[firstnumber=last, escapechar=~]
<effect> ::= ()
<effect> ::= (and <c-effect>*)
<effect> ::= <c-effect>
<c-effect> ::=~\specReq{:conditional-effects}~ ~\linebreak~(forall (<variable>*) <effect>)
<c-effect> ::=~\specReq{:conditional-effects}~ ~\linebreak~(when <gd> <cond-effect>)
<c-effect> ::= <p-effect>
<p-effect> ::= (not <atomic formula(term)>)
<p-effect> ::= <atomic formula(term)>
<cond-effect> ::= (and <p-effect>*)
<cond-effect> ::= <p-effect>
\end{lstlisting}

%
%  Temporal Method Definition
%
% From PDDL 3.0 add to HDDL 2.1

\noindent The temporal and numeric definitions of effects are as follows:

\begin{lstlisting}[firstnumber=last, escapechar=~]
<da-effect> ::= (and <da-effect>*)
<da-effect> ::= <timed-effect>
<da-effect> ::=~\specReq{:conditional-effects}~ (forall ~\linebreak~(<typed list (variable)>) <da-effect>)
<da-effect> ::=~\specReq{:conditional-effects}~ ~\linebreak~(when <da-gd> <timed-effect>)
<timed-effect> ::= ~\linebreak~(~at <time-specifier> <cond-effect>)~
<timed-effect> ::=~\specReq{:numeric-fluents}~ ~\linebreak~(~at <time-specifier> <f-assign-da>)~
<timed-effect> ::=~\specReq{:continuous-effects + :numeric-fluents}~ ~\linebreak~(<assign-op-t> <f-head> <f-exp-t>)
<f-assign-da> ::= (<assign-op> <f-head>~\linebreak ~<f-exp-da>)
<f-exp-da> ::= (<binary-op> <f-exp-da>~\linebreak ~ <f-exp-da>)
<f-exp-da> ::= (<multi-op> <f-exp-da>~\linebreak ~ <f-exp-da>+)
<f-exp-da> ::= (- <f-exp-da>)
<f-exp-da> ::=~\specReq{:duration-inequalities}~ ?duration
<f-exp-da> ::= <f-exp>
<assign-op-t> ::= increase
<assign-op-t> ::= decrease
<f-exp-t> ::= (* <f-exp> #t)
<f-exp-t> ::= (* #t <f-exp>)
<f-exp-t> ::= #t
\end{lstlisting}

\subsection{Problem Description}

%
% Problem Definition
%
% @HDDL 1.0 + initial timed literal + initial function values + metric spec
The problem definition includes as additional element the initial task network (line~\ref{l:tnihtn}) as in HDDL 1.0. But now, it is possible to define in the initial state of the problem initial function values and initial time literals. It is also possible to define metric specs on solution plans. We have chosen here not to allow the definition of preferences. But preferences could be added in a next extension of the language. Likewise we have also chosen not to allow the definition of constraints on plans although it is possible in PDDL. We believe that it is preferable to add constraints on plans by adding logical constraints associated with task networks. This allows for a more unified language.

\begin{lstlisting}[firstnumber=last, escapechar=~]
<problem> ::= (define (problem <name>)
    (:domain <name>)
    [<require-def>]
    [<object-declaration>]
    [<htn>]~\label{l:tnihtn}~
    <init>
    [<goal>])~\label{l:goal}~
    [<metric-spec>]~\specReq{:numeric-fluents}
\end{lstlisting}

\begin{lstlisting}[firstnumber=last, escapechar=~]
<object-declaration> ::= ~\linebreak~(:objects <typed list (name)>)
<init> ::= (:init <init-el>*)
<init-el> ::= <literal (name)>
<init-el> ::=~\specReq{:timed-initial-literals}~(~at ~<number>~ <literal (name)>)~
<init-el> ::=~\specReq{:numeric-fluents}~ (= ~<basic-function-term>~ <number>)
<basic-function-term> ::= <function-symbol>
<basic-function-term> ::= (<function-symbol> <name>*)
<goal> ::= (:goal <gd>)
\end{lstlisting}

The initial task network contains the definition of the problem class.

\begin{lstlisting}[firstnumber=last, escapechar=~]
<htn> ::= (:htn
    [:parameters (<typed list (variable)>)] ~\label{l:tniparams}~
    <tasknetwork-def>)~\label{l:tnitasks}~
\end{lstlisting} %| :tihtn~\specReq{:tihtn}~

%
% Metric spec
%
% @HDDL 2.1

The optional metric spec can be defined using the same syntax as in PDDL 3.0.

\begin{lstlisting}[firstnumber=last, escapechar=~]
<metric-spec> ::=~\specReq{:numeric-fluents}~
    (:metric <optimization> <metric-f-exp>)
<optimization> ::= ~minimize~
<optimization> ::= ~maximize~
<metric-f-exp> ::= (<binary-op>
    <metric-f-exp> <metric-f-exp>)
<metric-f-exp> ::= (<multi-op>
    <metric-f-exp> <metric-f-exp>+)
<metric-f-exp> ::= (- <metric-f-exp>)
<metric-f-exp> ::= <number>
<metric-f-exp> ::= ( <function-symbol>
    <name>* )
<metric-f-exp> ::= <function-symbol>
<metric-f-exp> ::= ~total-time
\end{lstlisting}

\subsection{Temporal and Numeric HDDL Requirements}
\label{Sec:Requirements}
The overall definition includes all the following requirement flags as in HDDL 1.0:
\begin{itemize}
 \item \verb+:hierarchy+ requires the applied system to support HTN planning, so this can be seen as the basic requirement for the language defined here.
 \item \verb+:method-preconditions+ requires the applied system to support method preconditions or condition when define in durative methods.
\end{itemize}
But now, the following requirement flags are also compatible with HDDL 2.1:
\begin{description}
 \item \verb+:durative-actions+ requires the applied system to support durative actions and temporal ordering constraints in method definitions.
 \item \verb+:duration-inequalities+ requires the applied system to support duration inequalities in durative actions declarations. Implies \verb+:durative-actions+.
 \item \verb+:timed-initial-literals+ requires the applied system to support initial state with literals that become true at a specified time point. Implies \verb+:durative-actions+.
 \item \verb+:numeric-fluent+ requires the applied system to support numeric fluents in preconditions and effects of actions and methods.
 \item \verb+:continuous-effects+ requires the applied system to support continuous action effects.
 \end{description}
 We add the following requirement flag:
\begin{description}
\item \verb+:method-constraints+ requires to specify decomposition trajectory constraints in methods.
 \end{description}

\section{Conclusion}

\bibliography{ref}

\end{document}
